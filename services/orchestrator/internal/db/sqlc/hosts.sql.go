// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: hosts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllHosts = `-- name: GetAllHosts :many
SELECT id, mac_address, hostname, ip_address, last_heartbeat, created_at FROM hosts
`

// Retrieves all hosts from the database.
func (q *Queries) GetAllHosts(ctx context.Context) ([]Host, error) {
	rows, err := q.db.Query(ctx, getAllHosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Host
	for rows.Next() {
		var i Host
		if err := rows.Scan(
			&i.ID,
			&i.MacAddress,
			&i.Hostname,
			&i.IpAddress,
			&i.LastHeartbeat,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHostByMacAddress = `-- name: GetHostByMacAddress :one
SELECT id, mac_address, hostname, ip_address, last_heartbeat, created_at FROM hosts WHERE mac_address = $1
`

// Retrieves a host by its mac_address.
func (q *Queries) GetHostByMacAddress(ctx context.Context, macAddress string) (Host, error) {
	row := q.db.QueryRow(ctx, getHostByMacAddress, macAddress)
	var i Host
	err := row.Scan(
		&i.ID,
		&i.MacAddress,
		&i.Hostname,
		&i.IpAddress,
		&i.LastHeartbeat,
		&i.CreatedAt,
	)
	return i, err
}

const insertHost = `-- name: InsertHost :one
INSERT INTO hosts (
  mac_address,
  hostname,
  ip_address
) VALUES (
  $1, $2, $3
)
ON CONFLICT (mac_address)
DO UPDATE SET
  hostname = EXCLUDED.hostname,
  ip_address = EXCLUDED.ip_address
RETURNING id, mac_address, hostname, ip_address, last_heartbeat, created_at
`

type InsertHostParams struct {
	MacAddress string `json:"mac_address"`
	Hostname   string `json:"hostname"`
	IpAddress  string `json:"ip_address"`
}

// Inserts a new host or updates an existing one based on the MAC address.
func (q *Queries) InsertHost(ctx context.Context, arg InsertHostParams) (Host, error) {
	row := q.db.QueryRow(ctx, insertHost, arg.MacAddress, arg.Hostname, arg.IpAddress)
	var i Host
	err := row.Scan(
		&i.ID,
		&i.MacAddress,
		&i.Hostname,
		&i.IpAddress,
		&i.LastHeartbeat,
		&i.CreatedAt,
	)
	return i, err
}

const updateHostLastHeartbeat = `-- name: UpdateHostLastHeartbeat :one
UPDATE hosts SET last_heartbeat = NOW() WHERE id = $1 RETURNING id, mac_address, hostname, ip_address, last_heartbeat, created_at
`

// Updates the last heartbeat timestamp for a host identified by id.
func (q *Queries) UpdateHostLastHeartbeat(ctx context.Context, id pgtype.UUID) (Host, error) {
	row := q.db.QueryRow(ctx, updateHostLastHeartbeat, id)
	var i Host
	err := row.Scan(
		&i.ID,
		&i.MacAddress,
		&i.Hostname,
		&i.IpAddress,
		&i.LastHeartbeat,
		&i.CreatedAt,
	)
	return i, err
}
